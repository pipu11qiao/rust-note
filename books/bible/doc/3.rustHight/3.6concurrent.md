# 并发与并行

并发与并行都是对多任务处理的描述，并发是轮流处理，并行是同时处理。


# 3.6.2 使用线程

### 多线程编程的风险

由于多线程是同时运行的，无法保证线程间的执行顺序，会导致：

* 静态条件，多个线程以非一致性的顺序同时访问数据资源
* 死锁（deadlocks),两个线程都像使用某个资源，但是又都在等待对方释放资源后才能使用，结果都无法执行
* 一些因为多线程导致的很隐晦的bug，难以复现和解决


### 创建线程

使用thread::spawn可以创建线程

* 线程内部的代码使用闭包来执行
* main 线程一旦结束，程序就会立刻结束，因此需要保持他的存活，知道其它子线程完成自己的任务
* thread::sleep 会让当前线程休眠制定的时间，随后其他线程会被调度运行。

千万不要依赖线程的执行顺序

#### 等待子线程的结束

```rust
let handle = thread::spawn(||{});
handle.join().unwrap();
```

通过调用handle.join(),可以让当前线程阻塞，知道它等待的线程的结束

#### 在线程闭包中使用 move


# 3.6.3 线程间的消息传递

### 消息通道
std::sync::mpsc

mpsc multiple produce, single consumer 多个发送者一个接收者

```rust
//创建一个消息通道, 返回一个元组：(发送者，接收者)
let (tx,rx) = mpsc::channel();
```
在发送线程中使用tx.send()方法发送消息

在接收线程中使用rx.recv()方法接受消息

两者的返回值都是Result<T,E>

tx,rx对应发送者和接收者，它们的类型由编译器自动推导: tx.send(1)发送了整数，因此它们分别是mpsc::Sender<i32>和mpsc::Receiver<i32>类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值, 例如此例中非i32类型的值将导致编译错误
接收消息的操作rx.recv()会阻塞当前线程，直到读取到值，或者通道被关闭
需要使用move将tx的所有权转移到子线程的闭包中

tx.send() 到 rx.recv()方法需要一定的时间

#### 不阻塞的try_recv方法

使用rx.try_recv()方法尝试接收消息，该方法不会阻塞线程，当通道中没有消息是会立刻返回一个错误。



#### 传输具有所有权的数据

使用通道来传输数据，一样要遵循 Rust 的所有权规则：

* 若值的类型实现了Copy特征，则直接复制一份该值，然后传输过去，例如之前的i32类型
* 若值没有实现Copy，则它的所有权会被转移给接收端，在发送端继续使用该值将报错

发送者发送一个String类型的对象，接受者接手后有可能对其进行操作。 两个线程都可以操作该对象会造成不安全，一个改变会引起另一个改变。

### 使用for进行循环接受
```rust
for recieved in rx {
  println!("Got: {}",received);
}
```
接受的for循环阻塞的从rx迭代器接受消息，当子线程运行完成时，发送者ts会被drop，此时fro循环终止，最终main线程成功结束。

### 使用多发送者

让每个发送的线程拿走，tx的clone来发送消息



# 同步和异步通道

Rust标准库的mpsc通道其实分为两种： 同步和异步

  let (tx, rx)= mpsc::channel();
   let (tx, rx)= mpsc::sync_channel(0);

同步通道
同步通道发送的消息是阻塞的，只有在消息被接收后才能解除阻塞

#### 消息缓存


mpsc::sync_channel(0); 中的数值0表示消息缓存的数量，如果发送者将消息放，但接受这没有消费，消息就会缓存在内存中，只有消费者消费后消息才得到释放。 异步通道和规定了一些缓存数量的同步通道可以进行很多的消息发送。如果消息太多会导致内存占用太多

#### 关闭通道

通道关闭的条件： 所有发送者被drop或者所有接受者被drop后，通道会自动关闭

#### 传输多种类型的数据

之前提到过，一个消息通道只能传输一种类型的数据，如果你想要传输多种类型的数据，可以为每个类型创建一个通道，你也可以使用枚举类型来实现：


### 注意


# 线程同步： 锁、Condvar和信号量

共享内存来实现同步性， 通过锁和原子操作等并发原语来实现多个线程同时且安全的去访问一个资源


## 互斥锁 Mutex

并发原语， 互斥锁Mutex(mutual exclusion)

Mutex让多个线程并发的访问同一个值变成了排队访问： 同一时间，只允许一个线程访问该值，其他线程需要等待A访问完成后才能继续

#### 单线程中使用 Mutex

```rust
use std::sync::Mutex;

fn main() {
    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }
    println!("m={:?}", m)
}
```


Mutex::new 创建互斥锁实例
m.lock() 向m申请一个锁，该方法会阻塞当前线程，直到获取到锁，因此当多个线程同时访问该数据时，只有一个线程能获取到锁,其他线程只能阻塞的等待。
m.lock() 方法也可能报错， 例如当前持有锁的线程panic了，在这种情况下，其他线程不可能获得锁。

Mutext<T>是一个智能指针，准确的说m.lock()返回一个智能指针MutextGuard<T>:

* 它实现了Deref特征，会被自动解引用后获得一个引用类型，该引用指向Mutex内部的数据
* 它还实现了Drop特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁