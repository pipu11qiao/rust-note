
既然会有生命周期的问题，为什么不干脆使用复合类型对象，而不使用引用类型。

1. 使用引用类型可以避免所有权问题。


```rust
struct Book {
    name: String,
}
impl Book {
    fn new(name: String) -> Self {
        Book { name }
    }
}

pub fn main() {
    let js_book = "js_book".to_string();

    let num = 5;

    if num > 5 {
        Book::new(js_book);
    } else {
        Book::new(js_book);
    }
    Book::new(js_book);
}
```

# 认识生命周期

生命周期，简而言之就是引用的有效作用域。
就像编译器大部分时候可以自动推导类型 <-> 一样，编译器大多数时候也可以自动推导生命周期
在多种类型存在时，编译器往往要求我们手动标明类型 <-> 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期

## 悬垂指针和生命周期

生命周期的主要作用是避免悬垂引用。

### 借用检查

Borrow checker

### 生命周期标注语法

标记的生命周期只是为了取悦编译器，让编译器不要难为我们。


### 函数中的生命周期

在通过函数签名指定生命周期参数时，我们并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过。

## 声明周期消除

编译器为了简化用户的使用，运用了生命周期消除大法。

在开始之前有几点需要注意：

消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期
函数或者方法中，参数的生命周期被称为 输入生命周期，返回值的生命周期被称为 输出生命周期

## 三条消除规则

编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。

1. 每一个引用参数都会获得独自的声明周期
2. 若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期
3. 若存在多个输入生命周期，且其中一个是 &self 或 &mut self，则 &self 的生命周期被赋给所有的输出生命周期