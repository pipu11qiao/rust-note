# 所有权和借用

## 栈

栈的数据存储方式

栈中的数据占用已知并且是固定大小的内存空间

## 堆

对于大小未知或可能变化的数据，需要将它存储到堆上

开辟堆内存，返回指针，该过程称为在堆上分配内存， 分配(allocating);

指针的大小是固定且已知的，使用过程中通过栈中的指针来获取堆上的数据。

## 所有权与堆栈

因为堆栈上的数据缺乏组织，因此跟踪这些数据合适分配和释放是非常重要的，否则堆上的数据将产生内存泄漏。

# 所有权原则

1. Rust 中的每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说只能有一个所有者
3. 当所有者离开作用域时，这个值将被丢弃，执行 drop()方法

变量绑定背后的数据交互

基本数据类型，是通过自动拷贝来赋值的。

符合类型是由存储在栈中的堆指针，字符串长度，字符串容量来共同组成。
当变量离开作用域后，Rust 会通过自动调用 drop 函数并清理变量的堆内存。如果一个值有两个所有者，会引起二次释放的错误。

复杂数据类型的移动操作

```rust
let s2 = s1;
```

```rust
fn main(){
  let x:&str = "hello,world";
  let y = x;
  println!("{},{}",x,y);
}
```

x 为引用了存储在二进制中的字符串"hello,world",并没有持有所有权。

clone() 方法产生一个新的值

Rust 有一个叫做 Copy 的特征，可以用在类似整型这样的在栈中存储的类型。任何基本类型的组合可以 Copy,不需要分配内存或某种形式资源的类型是可以 Copy 的。

- 整型，布尔，浮点，字符
- 元组，包含的类型也都是 Copy 类型
- 不可变引用&T, 可变&mut T 是不可以 Copy 的

### 函数值与返回

将值传递给函数，一样会发生移动或者复制，就跟 let 语句一样，下面的代码展示了所有权、作用域的规则：

所有权很强大，避免了内存的不安全行，但是也带来了一个新的麻烦： 总是把一个值传来传去使用它。

# 引用和借用

获取变量的引用，称之为借用（borrowing)

### 引用和解引用

常规引用是一个指针类型，指向了对象存储的内存地址。

```rust
fn main(){
  let x= 5;
  let y = &x;
  assert_eq!(5,x);
  assert_eq!(5,*y);
}
```

& 符号即是引用，它们允许你使用值，但是不获取所有权。因为不拥有这个值，有的只是指向原变量的一个引用。


### 可变引用

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
##### 可变引用同时只能存在一个

同一作用域，特定数据只能有一个可变引用。

限制来自borrow checker 特性之一
这种限制的好处是： rust在编译器就避免数据竞争，数据竞争可由以下行为造成：

* 两个或更多的指针通时访问同一数据
* 至少有一个指针被用来写入数据
* 没有同步数据访问机制

#### 可变引用和不可变引用同时存在

引用的作用域和变量的作用域存在不一样的地方
引用的作用域是指 从创建开始，一直持续到最后一次使用的地方
变量的作用域是从创建到某一个花括号

##### NLL

Non-Lexical Lifetimes(NLL)

### 悬垂引用(Dangling References)

rust编译器可以确保引用永远也不会变成悬垂状态： 当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的数据。

在函数返回引用的时候要注意返回的引用是否被使用，因为引用的对象在函数执行完后已经被释放。


### 借用规则

* 同一时刻，可以拥有要么一个可变引用，要么任意多个不可变引用
* 引用必须总是有效的

